%
%

\documentclass[11pt,a4paper,oneside]{book}

\usepackage[spanish]{babel}
%-------------------------------------------------------------------
% Esto es para poder escribir acentos directamente:
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%-----------------------------------------------------------------------
% para uso en modo matamático
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{hyperref}

\usepackage{pdfpages}
\usepackage{verbatim} % para el codigo
\usepackage{listings} % para codigo con formateado mas complejo
\usepackage{codigo}

%\lstset{style = codigo}

\usepackage{graphicx} 
\graphicspath{{Figuras/}} % se fija el camino para las figuras

\usepackage{longtable} % Tablas largas

\begin{document}

%\tableofcontents % indice de contenidos
 
\chapter{Introducción}

\chapter{Code Smells}

\section{Monstruos - Bloaters}

Bloaters are code, methods and classes that have increased to such gargantuan proportions that they are hard to work with. Usually these smells do not crop up right away, rather they accumulate over time as the program evolves (and especially when nobody makes an effort to eradicate them).
\label{metodolargo}
\subsection{Método largo -   Long Method}
\subsubsection{Signos y Sintomas - Signs and Symptoms}

Un método que contiene demasiadas lineas de código, cualquier método que contenga mas de diez lineas, debería hacer que te preguntes si está bien.

\textit{A method contains too many lines of code. Generally, any method longer than ten lines should make you start asking questions.}

\subsubsection{Razones para el problema - Reasons for the Problem}

Como el Hotel California, algo que esta siempre siendo añadido a un método pero nunca es usado. Es más fácil escribir el código que leerlo, este ``olor" permanece impredecible hasta que el método se vuelve feo, desconmensurado. 

Mentalmente, a veces es más difícil crear un nuevo método que añadir a uno existente: "Pero si son solo dos lineas, no hay motivo para crear un método entero solo para eso..." Lo que significa que otra linea es agregada y luego otra, dando nacimiento a un enredo de spaghetti code. 



\textit{Like the Hotel California, something is always being added to a method but nothing is ever taken out. Since it is easier to write code than to read it, this “smell” remains unnoticed until the method turns into an ugly, oversized beast.}

\textit{Mentally, it is often harder to create a new method than to add to an existing one: “But it’s just two lines, there’s no use in creating a whole method just for that...” Which means that another line is added and then yet another, giving birth to a tangle of spaghetti code.}

\subsubsection{Tratamiento - Treatment}
Como una regla de oro, si sientes la necesidad de comentar algo dentro de un método, deberías mover este código a un nuevo método. Incluso una sola linea puede y debe ser dividida en un método separado, si esto requiere comentarios. Y si el método tiene un nombre descriptivo, nadie necesitará mirar código para ver que hace.

\textit{As a rule of thumb, if you feel the need to comment on something inside a method, you should take this code and put it in a new method. Even a single line can and should be split off into a separate method, if it requires explanations. And if the method has a descriptive name, nobody will need to look at the code to see what it does.}

\subsubsection{Como se resuelve}
  Para reducir la longitud de los métodos usar  \hyperref[sec:extractmethod]{prueba}
  Si las variables locales y los parámetros interfieren con la extracción de un método, usar \ref{replacetempwithquery}
  \ref{introduceparameterobject} o \ref{preservewholeobject}.
  Si ninguna de las soluciones anteriores ayuda, intenta mover el método entero a un objeto separado usando \ref{replacemethodwithmethodobject}.
  Operadores condicionales y bucles son buenas pistas de que el código puede moverse a un método separado. Para condicionales, usar \ref{descomposecondicional}. Si hay bucles en el camino intenta \ref{extractmethod} .





\subsection{Clase larga -   Large Class}
\subsubsection{Signos y Sintomas - Signs and Symptoms}

Una clase contiene muchos campos/métodos/lineas de código.

\textit{A class contains many fields/methods/lines of code.}


    
\subsection{Obsesión primitiva -   Primitive Obsession}
Clases normalmente empiezan siendo pequeñas. Pero conforme pasa el tiempo, ellas se vuelven grandes a medida que el programa crece.

Como el caso de los métodos largos también, programadores normalmente lo encuentran mentalmente menos costoso que colocar una nueva característica en una clase existente en luagr de crear una clase nueva para la característica. 

\textbf{Classes usually start small. But over time, they get bloated as the program grows.}

\textit{As is the case with long methods as well, programmers usually find it mentally less taxing to place a new feature in an existing class than to create a new class for the feature.}

\subsection{Una larga lista de parametros -   Long Parameter List}

\subsection{ -   Data Clumps}

    
    
    
    
    



%%%%%%%%%%%%%%%%%%%%%%%%%%%-----ALEJANDRO----%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object-Orientation Abusers} 

All these smells are incomplete or incorrect application of object-oriented programming principles.
    \newline
    
    \textbf{Switch Statements} \newline
    Traducido como \textit{cambio declarativo}, ocurre cuando tienes un operador \textit{switch} o secuencia de declaraciones \textit{if}.
    \newline
    
    \textbf{Temporary Field}  \newline
    Traducido como \textit{campos temporales}, ocurre cuando los campos temporales obtienen su valores(necesitados por objetos) solo bajo ciertas circunstancias. Fuera de estas circunstancias, están vacías.
    \newline
    
    \textbf{Refused Bequest}  \newline
    Traducido como \textit{rechazo de herencia}, ocurre si una \textit{subclase} usa solo alguno de los métodos y propiedades heredados de sus padres, la jerarquía esta fuera de lugar. Los métodos no necesarios pueden simplemente acabar sin ser usados o ser redefinidos y lanzar excepciones.
    \newline
    
    \textbf{Alternative Classes with Different Interfaces}  \newline
    Traducido como \textit{clases alternativas con interfaces distintas}, ocurre cuando dos clases llevan a cabo funciones idénticas pero usan nombres de método distinto.
    \newline


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%-----Francisco Jesús----%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preventores de cambio}

Consiste en que si tienes que cambiar algo en un lugar del código, tienes que realizar también muchos cambios en otros lugares. El desarrollo se vuelve más complicado y costoso.

\subsection{Cambios divergentes}

Cuando haces un cambio en una clase te encuentras con que tienes que cambiar muchos métodos que no están relacionados con el cambio. Por ejemplo, al añadir un nuevo tipo de producto tienes que cambiar los métodos de buscar, mostrar y pedir productos.
\newline
Suelen surgir por una estructura pobre o por la programación copiar-pegar.

\textbf{Soluciones}
\begin{itemize}
    \item Dividir el comportamiento de la clase, con la refactorización de extraer clase \ref{extractclass}.
    \item Si varias clases tienen el mismo comportamiento, se puede combinar mediante herencia (refactorizaciones de Extraer Superclase \ref{extractsuperclass} y Extraer Subclase \ref{extractsubclass}).
\end{itemize}
\newline
\textbf{Ventajas}
\begin{itemize}
    \item Mejora la organización del código.
    \item Reduce la duplicación del código.
    \item Simplifica el soporte.
\end{itemize}
    
    
Improves code organization.

Reduces code duplication.

Simplifies support.

\subsection{    Shotgun Surgery}

Se resuelve con las técnicas: renombrar método \ref{renombrarmetodo}

    Parallel Inheritance Hierarchies



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Prescindibles - Dispensables}

%A dispensable is something pointless and unneeded whose absence would make the code cleaner, more efficient and easier to understand.%

Un dispensable es aquello in


    Comments - Comentarios
    
    Duplicate Code
    
    Lazy Class

    Data Class

Dead Code

    Speculative Generality



\section{Couplers}

All the smells in this group contribute to excessive coupling between classes or show what happens if coupling is replaced by excessive delegation.

    Feature Envy
    
    Inappropriate Intimacy
    
    Message Chains
    
    Middle Man

    Incomplete Library Class


\section{Other Smells}

Below are the smells which do not fall into any broad category.

Incomplete Library Class

Sooner or later, libraries stop meeting user needs. The only solution to the problem – changing the library – is often impossible since the library is read-only.



\chapter{Técnicas de refactorización}


\section{Composing methods}

Much of refactoring is devoted to correctly composing methods. In most cases, excessively long methods are the root of all evil. The vagaries of code inside these methods conceal the execution logic and make the method extremely hard to understand – and even harder to change.

The refactoring techniques in this group streamline methods, remove code duplication, and pave the way for future improvements.

\subsection{Extraer Método  - Extract Method}\label{sec:extractmethod}
\begin{itemize}
    \item \textbf{Problema} Tiene un fragmento de código que se puede agrupar.
    \item \textbf{Solución} Mueva este código a un nuevo método (o función) separado y reemplace el código antiguo con una llamada al método.
\end{itemize}
    
\subsection{Método en líbea - Inline Method}
\label{inlinemethod}
\begin{itemize}
    \item \textbf{Problema} Cuando el cuerpo de un método es más obvio que el método en sí, use esta técnica.
    \item \textbf{Solución} Reemplace las llamadas al método con el contenido del método y elimine el método en sí.
\end{itemize}

\subsection{Extraer variable - Extract Variable}
\label{extracvariable}
\begin{itemize}
    \item \textbf{Problema} Tienes una expresión que es difícil de entender.
    \item \textbf{Solución} Coloque el resultado de la expresión o sus partes en variables separadas que se explican por sí mismas.
\end{itemize}
    
\subsection{Temperatura en línea - Inline Temp}
\label{inlinetemp}
\begin{itemize}
    \item \textbf{Problema} Tiene una variable temporal a la que se le asigna el resultado de una expresión simple y nada más.
    \item \textbf{Solución} Reemplace las referencias a la variable con la expresión misma.
\end{itemize}
    
\subsection{Reemplazar temporales con consulta - Replace Temp with Query}
\label{replacetempwithquery}
\begin{itemize}
    \item \textbf{Problema} Coloca el resultado de una expresión en una variable local para su uso posterior en su código.
    \item \textbf{Solución} Mueva la expresión completa a un método separado y devuelva el resultado. Consulte el método en lugar de usar una variable. Incorpore el nuevo método en otros métodos, si es necesario.
\end{itemize}
    
    Split Temporary Variable
    
    Remove Assignments to Parameters
    
    Replace Method with Method Object
    
    Substitute Algorithm


\section{Mover Características entre Objetos - Moving Features between Objects}

\label{renombrarmetodo} Incluso si se ha distribuido la funcionalidad entre diferentes clases de manera imperfecta, todavía sigue habiendo esperanza.
Estas técnicas de refactorización nos muestran como mover funcionalidad entre clases. crear nuevas clases y ocultar los detalles de implementación al acceso público de manera segura.


\subsection{Mover Métodos - Move Method}  
\begin{itemize}
    \item \textbf{Problema} Un método es más utilizado en otra clase que en la suya propia.
    \item \textbf{Solución} Crear un método en la clase donde el método se utiliza más, mover el código del método anterior al que hemos creado. Transformar el código del método original en una referencia al nuevo método de la otra clase o podemos eliminarlo por completo.
\end{itemize}
    
\subsection{Mover Campos - Move Field}
\begin{itemize}
    \item \textbf{Problema} Un campo es más utilizado en otra clase que en la suya propia.
    \item \textbf{Solución} Crear un campo en una nueva clase y redirigir a todos los usuarios del campo anterior a este.
\end{itemize}
    
\subsection{Extraer Clases - Extract Class}
\begin{itemize}
    \item \textbf{Problema} Una clase hace el trabajo que deberían hacer dos.
    \item \textbf{Solución} Crear una nueva clase para la segunda funcionalidad y colocar los campos y métodos correspondientes en esta.
\end{itemize}
    
\subsection{Clases Entrelíneas - Inline Class}
\begin{itemize}
    \item \textbf{Problema} Un método apenas tiene funcionalidad no es responsable de nada y no se plantea agregarle nada nuevo.
    \item \textbf{Solución} Mover todas las características a otra clase.
\end{itemize}
    
\subsection{Esconder Delegado - Hide Delegate}
 \begin{itemize}
    \item \textbf{Problema} Un método apenas tiene funcionalidad no es resposable de nada y no se plantea agregarle nada nuevo.
    \item \textbf{Solución} Mover todas las características a otra clase.
\end{itemize}

    Remove Middle Man
    
    Introduce Foreign Method
    
    Introduce Local Extension



\section{Organizing Data}

These refactoring techniques help with data handling, replacing primitives with rich class functionality. Another important result is untangling of class associations, which makes classes more portable and reusable.

    Self Encapsulate Field
    
    Replace Data Value with Object
    
    Change Value to Reference
    
    Change Reference to Value
    
    Replace Array with Object
    
    Duplicate Observed Data
    
    Change Unidirectional Association to Bidirectional
    
    Change Bidirectional Association to Unidirectional
    
    Replace Magic Number with Symbolic Constant
    
    Encapsulate Field
    
    Encapsulate Collection
    
    Replace Type Code with Class
    
    Replace Type Code with Subclasses
    
    Replace Type Code with State/Strategy
    
    Replace Subclass with Fields




\section{Simplifying Conditional Expressions}

Conditionals tend to get more and more complicated in their logic over time, and there are yet more techniques to combat this as well.

    Decompose Conditional
    
    Consolidate Conditional Expression
    
    Consolidate Duplicate Conditional Fragments
    
    Remove Control Flag

    Replace Nested Conditional with Guard Clauses
    
    Replace Conditional with Polymorphism
    
    Introduce Null Object
    
    Introduce Assertion





\section{Simplifying Method Calls}

These techniques make method calls simpler and easier to understand. This, in turn, simplifies the interfaces for interaction between classes.

\subsection{     Renombrar método - Rename Method}
\label{renombrarmetodo}
\begin{itemize}
    \item \textbf{Problema} Aparece cuando un método no explica lo que hace 
    \item \textbf{Solución} Se renombra el método
\end{itemize}
    
%\lstinputlisting[firstline=1, firstnumber=1, nolol=true]{extractmethod.java}
\lstinputlisting[language = java]{extractmethod.java}

     
    
    Add Parameter
    
    Remove Parameter
    
    Separate Query from Modifier
    
    Parameterize Method
    
    Replace Parameter with Explicit Methods
    
    Preserve Whole Object
    
    Replace Parameter with Method Call
    
    Introduce Parameter Object
    
    Remove Setting Method
    
    Hide Method
    
    Replace Constructor with Factory Method
    
    Replace Error Code with Exception
    
    Replace Exception with Test




\section{Dealing with Generalisation}

Abstraction has its own group of refactoring techniques, primarily associated with moving functionality along the class inheritance hierarchy, creating new classes and interfaces, and replacing inheritance with delegation and vice versa.

    Pull Up Field
    
    Pull Up Method
    
    Pull Up Constructor Body
    
    Push Down Method
    
    Push Down Field
    
    Extract Subclass
    
    Extract Superclass
    
    Extract Interface
    
    Collapse Hierarchy
    
    Form Template Method
    
    Replace Inheritance with Delegation
    
    Replace Delegation with Inheritance


\section{Otras refactorizaciones de Fowler}
% https://refactoring.com/catalog/
\subsection{Grupo 1}
Change Function Declaration

Change Signature 

Inline Function

Inline Variable

Introduce Explaining Variable

Introduce Special Case

Move Function

Move Statements into Function

Move Statements to Callers

%%%%%%%%%%%%%%%%%%%%%%%%%-Alejandro-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Grupo 2}
\textbf{Parameterize Function}

\begin{itemize}
    \item \textbf{Problema} Tiene un fragmento de código que se puede agrupar.
    \item \textbf{Solución} Mueva este código a un nuevo método (o función) separado y reemplace el código antiguo con una llamada al método.
\end{itemize}


\textbf{Remove Flag Argument}

\begin{itemize}
    \item \textbf{Problema} Tiene un fragmento de código que se puede agrupar.
    \item \textbf{Solución} Mueva este código a un nuevo método (o función) separado y reemplace el código antiguo con una llamada al método.
\end{itemize}


\textbf{Remove Subclass}

\begin{itemize}
    \item \textbf{Problema} Tiene un fragmento de código que se puede agrupar.
    \item \textbf{Solución} Mueva este código a un nuevo método (o función) separado y reemplace el código antiguo con una llamada al método.
\end{itemize}

\textbf{Rename Field}

\begin{itemize}
    \item \textbf{Problema} Tiene un fragmento de código que se puede agrupar.
    \item \textbf{Solución} Mueva este código a un nuevo método (o función) separado y reemplace el código antiguo con una llamada al método.
\end{itemize}

\textbf{Rename Function}

\begin{itemize}
    \item \textbf{Problema} Tiene un fragmento de código que se puede agrupar.
    \item \textbf{Solución} Mueva este código a un nuevo método (o función) separado y reemplace el código antiguo con una llamada al método.
\end{itemize}

\textbf{Rename Variable}

\begin{itemize}
    \item \textbf{Problema} Tiene un fragmento de código que se puede agrupar.
    \item \textbf{Solución} Mueva este código a un nuevo método (o función) separado y reemplace el código antiguo con una llamada al método.
\end{itemize}

\textbf{Replace Command with Function}

\begin{itemize}
    \item \textbf{Problema} Tiene un fragmento de código que se puede agrupar.
    \item \textbf{Solución} Mueva este código a un nuevo método (o función) separado y reemplace el código antiguo con una llamada al método.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Grupo 3}
Replace Constructor with Factory Method

Replace Control Flag with Break

Replace Derived Variable with Query

Replace Exception with Precheck

Replace Function with Command

Replace Inline Code with Function Call

\subsection{Grupo 4}
Replace Loop with Pipeline

Replace Magic Literal

Replace Parameter with Query

Replace Primitive with Object

Replace Query with Parameter

Replace Record with Data Class

Replace Subclass with Delegate

\subsection{Grupo 5}
Replace Superclass with Delegate

Replace Type Code with Class

Return Modified Value

Slide Statements

Split Loop

Split Phase

Split Variable



\chapter*{Correspondencia entre refactorizaciones}

\begin{longtable}{|p{200pt}|p{200pt}|}
\footnotesize
 Categoría Fowler &Categoría refactorización\\ 
\hline
    Add Parameter & Add Parameter\\ 
    Change Bidirectional Association to Unidirectional & \\ 
    Change Reference to Value & Change Reference to Value\\ 
    Change Unidirectional Association to Bidirectional & \\ 
    Change Value to Reference & Change Value to Reference\\ 
    Collapse Hierarchy & Collapse Hierarchy\\ 
 & Combine Functions into Class\\ 
 & Combine Functions into Transform\\ 
    Consolidate Conditional Expression & Consolidate Conditional Expression\\ 
    Consolidate Duplicate Conditional Fragments & Consolidate Duplicate Conditional Fragments\\ 
    Decompose Conditional & Decompose Conditional\\ 
    Duplicate Observed Data & \\ 
    Encapsulate Collection & Encapsulate Collection\\ 
    Encapsulate Field & Encapsulate Field \\ 
 & Encapsulate Record\\ 
 & Encapsulate Variable\\ 
    Extract Class & Extract Class\\ 
    Extract Interface & Extract Function\\ 
    Extract Method & Extract Method\\ 
    Extract Subclass & Extract Subclass \\ 
    Extract Superclass & Extract Superclass\\ 
    Extract Variable & Extract Variable\\ 
    Form Template Method & \\ 
    Hide Delegate & Hide Delegate\\ 
    Hide Method & \\ 
    Inline Class & Inline Class\\ 
    Inline Method & Inline Method\\ 
    Inline Temp & Inline Temp\\ 
    Introduce Assertion & Introduce Assertion\\ 
    Introduce Foreign Method & \\ 
    Introduce Local Extension & \\ 
    Introduce Null Object & Introduce Null Object\\ 
    Introduce Parameter Object & Introduce Parameter Object\\ 
    Move Field & Move Field\\ 
    Move Method & Move Method\\ 
    Parameterize Method & Parameterize Method\\ 
    Preserve Whole Object & Preserve Whole Object\\ 
    Pull Up Constructor Body & Pull Up Constructor Body\\ 
    Pull Up Field & Pull Up Field\\ 
    Pull Up Method & Pull Up Method\\ 
    Push Down Field & Push Down Field\\ 
    Push Down Method & Push Down Method\\ 
    Remove Assignments to Parameters & Remove Assignments to Parameters \\ 
    Remove Control Flag & Remove Control Flag\\ 
    Remove Middle Man & Remove Middle Man\\ 
    Remove Parameter & Remove Parameter \\ 
    Remove Setting Method & Remove Setting Method\\ 
    Rename Method & Rename Method\\ 
    Replace Array with Object & \\ 
    Replace Conditional with Polymorphism & Replace Conditional with Polymorphism\\ 
    Replace Constructor with Factory Method & Replace Constructor with Factory Function\\ 
    Replace Data Value with Object & Replace Data Value with Object\\ 
    Replace Delegation with Inheritance & \\ 
    Replace Error Code with Exception & Replace Error Code with Exception\\ 
    Replace Exception with Test & Replace Exception with Test\\ 
    Replace Inheritance with Delegation & Replace Inheritance with Delegation\\ 
    Replace Magic Number with Symbolic Constant & Replace Magic Number with Symbolic Constant\\ 
    Replace Method with Method Object & Replace Method with Method Object\\ 
    Replace Nested Conditional with Guard Clauses & Replace Nested Conditional with Guard Clauses\\ 
    Replace Parameter with Explicit Methods & Replace Parameter with Explicit Methods\\ 
    Replace Parameter with Method Call & Replace Parameter with Method\\ 
    Replace Subclass with Fields & Replace Subclass with Fields\\ 
    Replace Temp with Query & Replace Temp with Query\\ 
    Replace Type Code with Class & \\ 
    Replace Type Code with State/Strategy & Replace Type Code with State/Strategy\\ 
    Replace Type Code with Subclasses & Replace Type Code with Subclasses\\ 
    Self Encapsulate Field & Self-Encapsulate Field\\ 
    Separate Query from Modifier & Separate Query from Modifier\\ 
    Split Temporary Variable & Split Temp\\ 
    Substitute Algorithm &     Substitute Algorithm\\
\end{longtable}





\chapter{Caso 1: Juan Soler}
% refactorizado por: 

\chapter{Caso 2: Alejandro Francisco}
\textbf{Refactorizador:} Juan Soler
\textbf{Refactoriza:} Francisco José Martín


\chapter {Caso 3: Francisco José Martín}
% refactorizar por: Alejandro Francisco


\chapter {Caso 4: Francisco Jesús García López}
\textbf{Refactorizador:} Francisco José Martín
\textbf{Refactoriza:} Adalid Abraham Villanueva Hermoza 



\chapter {Caso 5: Adalid Abraham Villanueva Hermoza}


\chapter {Caso 6: Marius Cosmin Magurean}
% refactorizado por: Adalid Abraham Villanueva Hermoza

\chapter {Caso 7: Jose Antonio Parra Sánchez}





\end{document}


