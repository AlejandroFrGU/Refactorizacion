%
%

\documentclass[11pt,a4paper,oneside]{book}

\usepackage[spanish]{babel}
%-------------------------------------------------------------------
% Esto es para poder escribir acentos directamente:
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%-----------------------------------------------------------------------
% para uso en modo matamático
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{verbatim} % para el codigo
\usepackage{listings} % para codigo con formateado mas complejo
\usepackage{codigo}

\lstset{style = codigo}

\usepackage{graphicx} 
\graphicspath{{Figuras/}} % se fija el camino para las figuras

\usepackage{longtable} % Tablas largas

\begin{document}

\tableofcontents % indice de contenidos
 
\chapter{Introducción}

\chapter{Code Smells}

\section{Monstruos - Bloaters}

Bloaters are code, methods and classes that have increased to such gargantuan proportions that they are hard to work with. Usually these smells do not crop up right away, rather they accumulate over time as the program evolves (and especially when nobody makes an effort to eradicate them).

\subsection{Método largo -   Long Method}
\subsubsection{Signos y Sintomas - Signs and Symptoms}

Un método que contiene demasiadas lineas de código, cualquier método que contenga mas de diez lineas, debería hacer que te preguntes si está bien.

A method contains too many lines of code. Generally, any method longer than ten lines should make you start asking questions.

\subsubsecReasons{Reasons for the Problem}

Como el Hotel California, algo que esta siempre siendo añadido a un método pero nunca es usado. Es más fácil escribir el código que leerlo, este "olor" permanece impredecible hasta que el método se vuelve feo, desconmensurado. 

Mentalmente, a veces es más difícil crear un nuevo método que añadir a uno existente: "Pero si son solo dos lineas, no hay motivo para crear un método entero solo para eso..." Lo que significa que otra linea es agregada y luego otra, dando nacimiento a un enredo de spaghetti code. 



Like the Hotel California, something is always being added to a method but nothing is ever taken out. Since it is easier to write code than to read it, this “smell” remains unnoticed until the method turns into an ugly, oversized beast.

Mentally, it is often harder to create a new method than to add to an existing one: “But it’s just two lines, there’s no use in creating a whole method just for that...” Which means that another line is added and then yet another, giving birth to a tangle of spaghetti code.

\subsubsection{Treatment}
Como una regla de oro, si sientes la necesidad de comentar algo dentro de un m

As a rule of thumb, if you feel the need to comment on something inside a method, you should take this code and put it in a new method. Even a single line can and should be split off into a separate method, if it requires explanations. And if the method has a descriptive name, nobody will need to look at the code to see what it does.

\subsection{Clase larga -   Large Class}

    
    \subsection{Obsesión primitiva -   Primitive Obsession}

        \subsection{Una larga lista de parametros -   Long Parameter List}
    \subsection{ -   Data Clumps}

    
    
    
    
    




\section{Object-Orientation Abusers}

All these smells are incomplete or incorrect application of object-oriented programming principles.

    Switch Statements
    
    Temporary Field

    Refused Bequest
    
    Alternative Classes with Different Interfaces





\section{Preventores de cambio}

Consiste en que si tienes que cambiar algo en un lugar del código, tienes que realizar también muchos cambios en otros lugares. El desarrollo se vuelve más complicado y costoso.

\subsection{Divergent Change}

    
\subsection{    Shotgun Surgery}

Se resuelve con las técnicas: renombrar método \ref{renombrarmetodo}

    Parallel Inheritance Hierarchies




\section{Prescindibles - Dispensables}

A dispensable is something pointless and unneeded whose absence would make the code cleaner, more efficient and easier to understand.

    Comments
    
    Duplicate Code
    
    Lazy Class

    Data Class

Dead Code

    Speculative Generality



\section{Couplers}

All the smells in this group contribute to excessive coupling between classes or show what happens if coupling is replaced by excessive delegation.

    Feature Envy
    
    Inappropriate Intimacy
    
    Message Chains
    
    Middle Man

    Incomplete Library Class


\section{Other Smells}

Below are the smells which do not fall into any broad category.

Incomplete Library Class

Sooner or later, libraries stop meeting user needs. The only solution to the problem – changing the library – is often impossible since the library is read-only.



\chapter{Técnicas de refactorización}


\section{Composing methods}

Much of refactoring is devoted to correctly composing methods. In most cases, excessively long methods are the root of all evil. The vagaries of code inside these methods conceal the execution logic and make the method extremely hard to understand – and even harder to change.

The refactoring techniques in this group streamline methods, remove code duplication, and pave the way for future improvements.

    Extract Method
    
    
    Inline Method

    
    
    Extract Variable
    
    
    Inline Temp
    
    
    Replace Temp with Query
    
    Split Temporary Variable
    
    Remove Assignments to Parameters
    
    Replace Method with Method Object
    
    Substitute Algorithm


\section{Mover Características entre Objetos - Moving Features between Objects}
Incluso si se ha distribuido la funcionalidad entre diferentes clases de manera imperfecta, todavía sigue habiendo esperanza.
Estas técnicas de refactorización nos muestran como mover funcionalidad entre clases. crear nuevas clases y ocultar los detalles de implementación al acceso público de manera segura.


    Move Method
    
    Move Field
    
    Extract Class
    
    Inline Class
    
    Hide Delegate
    
    Remove Middle Man
    
    Introduce Foreign Method
    
    Introduce Local Extension



\section{Organizing Data}

These refactoring techniques help with data handling, replacing primitives with rich class functionality. Another important result is untangling of class associations, which makes classes more portable and reusable.

    Self Encapsulate Field
    
    Replace Data Value with Object
    
    Change Value to Reference
    
    Change Reference to Value
    
    Replace Array with Object
    
    Duplicate Observed Data
    
    Change Unidirectional Association to Bidirectional
    
    Change Bidirectional Association to Unidirectional
    
    Replace Magic Number with Symbolic Constant
    
    Encapsulate Field
    
    Encapsulate Collection
    
    Replace Type Code with Class
    
    Replace Type Code with Subclasses
    
    Replace Type Code with State/Strategy
    
    Replace Subclass with Fields




\section{Simplifying Conditional Expressions}

Conditionals tend to get more and more complicated in their logic over time, and there are yet more techniques to combat this as well.

    Decompose Conditional
    
    Consolidate Conditional Expression
    
    Consolidate Duplicate Conditional Fragments
    
    Remove Control Flag

    Replace Nested Conditional with Guard Clauses
    
    Replace Conditional with Polymorphism
    
    Introduce Null Object
    
    Introduce Assertion





\section{Simplifying Method Calls}

These techniques make method calls simpler and easier to understand. This, in turn, simplifies the interfaces for interaction between classes.

\subsection{     Renombrar método - Rename Method}
\label{renombrarmetodo}
\begin{itemize}
    \item \textbf{Problema} Aparece cuando un método no explica lo que hace 
    \item \textbf{Solución} Se renombra el método
\end{itemize}
    
%\lstinputlisting[firstline=1, firstnumber=1, nolol=true]{extractmethod.java}
\lstinputlisting[language = java]{extractmethod.java}

     
    
    Add Parameter
    
    Remove Parameter
    
    Separate Query from Modifier
    
    Parameterize Method
    
    Replace Parameter with Explicit Methods
    
    Preserve Whole Object
    
    Replace Parameter with Method Call
    
    Introduce Parameter Object
    
    Remove Setting Method
    
    Hide Method
    
    Replace Constructor with Factory Method
    
    Replace Error Code with Exception
    
    Replace Exception with Test




\section{Dealing with Generalisation}

Abstraction has its own group of refactoring techniques, primarily associated with moving functionality along the class inheritance hierarchy, creating new classes and interfaces, and replacing inheritance with delegation and vice versa.

    Pull Up Field
    
    Pull Up Method
    
    Pull Up Constructor Body
    
    Push Down Method
    
    Push Down Field
    
    Extract Subclass
    
    Extract Superclass
    
    Extract Interface
    
    Collapse Hierarchy
    
    Form Template Method
    
    Replace Inheritance with Delegation
    
    Replace Delegation with Inheritance


\section{Otras refactorizaciones de Fowler}
% https://refactoring.com/catalog/
\subsection{Grupo 1}
Change Function Declaration

Change Signature 

Inline Function

Inline Variable

Introduce Explaining Variable

Introduce Special Case

Move Function

Move Statements into Function

Move Statements to Callers



\subsection{Grupo 2}
Parameterize Function

Remove Dead Code

Remove Flag Argument

Remove Subclass

Rename Field

Rename Function 

Rename Variable

Replace Command with Function

\subsection{Grupo 3}
Replace Constructor with Factory Method

Replace Control Flag with Break

Replace Derived Variable with Query

Replace Exception with Precheck

Replace Function with Command

Replace Inline Code with Function Call

\subsection{Grupo 4}
Replace Loop with Pipeline

Replace Magic Literal

Replace Parameter with Query

Replace Primitive with Object

Replace Query with Parameter

Replace Record with Data Class

Replace Subclass with Delegate

\subsection{Grupo 5}
Replace Superclass with Delegate

Replace Type Code with Class

Return Modified Value

Slide Statements

Split Loop

Split Phase

Split Variable



\chapter*{Correspondencia entre refactorizaciones}

\begin{longtable}{|p{200pt}|p{200pt}|}
\footnotesize
 Categoría Fowler &Categoría refactorización\\ 
\hline
    Add Parameter & Add Parameter\\ 
    Change Bidirectional Association to Unidirectional & \\ 
    Change Reference to Value & Change Reference to Value\\ 
    Change Unidirectional Association to Bidirectional & \\ 
    Change Value to Reference & Change Value to Reference\\ 
    Collapse Hierarchy & Collapse Hierarchy\\ 
 & Combine Functions into Class\\ 
 & Combine Functions into Transform\\ 
    Consolidate Conditional Expression & Consolidate Conditional Expression\\ 
    Consolidate Duplicate Conditional Fragments & Consolidate Duplicate Conditional Fragments\\ 
    Decompose Conditional & Decompose Conditional\\ 
    Duplicate Observed Data & \\ 
    Encapsulate Collection & Encapsulate Collection\\ 
    Encapsulate Field & Encapsulate Field \\ 
 & Encapsulate Record\\ 
 & Encapsulate Variable\\ 
    Extract Class & Extract Class\\ 
    Extract Interface & Extract Function\\ 
    Extract Method & Extract Method\\ 
    Extract Subclass & Extract Subclass \\ 
    Extract Superclass & Extract Superclass\\ 
    Extract Variable & Extract Variable\\ 
    Form Template Method & \\ 
    Hide Delegate & Hide Delegate\\ 
    Hide Method & \\ 
    Inline Class & Inline Class\\ 
    Inline Method & Inline Method\\ 
    Inline Temp & Inline Temp\\ 
    Introduce Assertion & Introduce Assertion\\ 
    Introduce Foreign Method & \\ 
    Introduce Local Extension & \\ 
    Introduce Null Object & Introduce Null Object\\ 
    Introduce Parameter Object & Introduce Parameter Object\\ 
    Move Field & Move Field\\ 
    Move Method & Move Method\\ 
    Parameterize Method & Parameterize Method\\ 
    Preserve Whole Object & Preserve Whole Object\\ 
    Pull Up Constructor Body & Pull Up Constructor Body\\ 
    Pull Up Field & Pull Up Field\\ 
    Pull Up Method & Pull Up Method\\ 
    Push Down Field & Push Down Field\\ 
    Push Down Method & Push Down Method\\ 
    Remove Assignments to Parameters & Remove Assignments to Parameters \\ 
    Remove Control Flag & Remove Control Flag\\ 
    Remove Middle Man & Remove Middle Man\\ 
    Remove Parameter & Remove Parameter \\ 
    Remove Setting Method & Remove Setting Method\\ 
    Rename Method & Rename Method\\ 
    Replace Array with Object & \\ 
    Replace Conditional with Polymorphism & Replace Conditional with Polymorphism\\ 
    Replace Constructor with Factory Method & Replace Constructor with Factory Function\\ 
    Replace Data Value with Object & Replace Data Value with Object\\ 
    Replace Delegation with Inheritance & \\ 
    Replace Error Code with Exception & Replace Error Code with Exception\\ 
    Replace Exception with Test & Replace Exception with Test\\ 
    Replace Inheritance with Delegation & Replace Inheritance with Delegation\\ 
    Replace Magic Number with Symbolic Constant & Replace Magic Number with Symbolic Constant\\ 
    Replace Method with Method Object & Replace Method with Method Object\\ 
    Replace Nested Conditional with Guard Clauses & Replace Nested Conditional with Guard Clauses\\ 
    Replace Parameter with Explicit Methods & Replace Parameter with Explicit Methods\\ 
    Replace Parameter with Method Call & Replace Parameter with Method\\ 
    Replace Subclass with Fields & Replace Subclass with Fields\\ 
    Replace Temp with Query & Replace Temp with Query\\ 
    Replace Type Code with Class & \\ 
    Replace Type Code with State/Strategy & Replace Type Code with State/Strategy\\ 
    Replace Type Code with Subclasses & Replace Type Code with Subclasses\\ 
    Self Encapsulate Field & Self-Encapsulate Field\\ 
    Separate Query from Modifier & Separate Query from Modifier\\ 
    Split Temporary Variable & Split Temp\\ 
    Substitute Algorithm &     Substitute Algorithm\\
\end{longtable}





\chapter{Caso 1: Juan Soler}
% refactorizado por: 

\chapter{Caso 2: Alejandro Francisco}
\textbf{Refactorizador:} Juan Soler
\textbf{Refactoriza:} Francisco José Martín


\chapter {Caso 3: Francisco José Martín}
% refactorizar por: Alejandro Francisco


\chapter {Caso 4: Francisco Jesús García López}
\textbf{Refactorizador:} Francisco José Martín
\textbf{Refactoriza:} Adalid Abraham Villanueva Hermoza 



\chapter {Caso 5: Adalid Abraham Villanueva Hermoza}


\chapter {Caso 6: Marius Cosmin Magurean}
% refactorizado por: Adalid Abraham Villanueva Hermoza

\chapter {Caso 7: Jose Antonio Parra Sánchez}





\end{document}


